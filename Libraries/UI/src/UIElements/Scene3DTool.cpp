//
// Created by Sven Hahne on 25.10.2021.
//

#include <UIElements/Scene3DTool.h>
#include <SceneNodes/SNGizmo.h>
#include <SceneNodes/SNGizmoPlane.h>
#include <DrawManagers/DrawManagerGizmo.h>
#include <UIWindow.h>

using namespace std;
using namespace glm;

using trm = ara::TrackBallCam::TransMapping;
using rm  = ara::TrackBallCam::RotateMapping;
using zm  = ara::TrackBallCam::ZoomMapping;

namespace fs = std::filesystem;

namespace ara {

Scene3DTool::Scene3DTool() {
    setName(getTypeName<Scene3DTool>());
}

Scene3DTool::Scene3DTool(const std::string &styleClass) : Div(styleClass) {
    setName(getTypeName<Scene3DTool>());
}

Scene3DTool::~Scene3DTool() {
    if (m_sharedRes && m_sharedRes->win) {
        auto uiWin = static_cast<UIWindow *>(m_sharedRes->win);
        uiWin->removeGlobalKeyDownCb(this);
        uiWin->removeGlobalKeyUpCb(this);
    }
}

void Scene3DTool::init() {
    Div::init();

  //  XmlParser parser(this);  // parse config file add subnodes

    // if we are in release mode load the xml from the Resources
#ifdef ARA_DEBUG
    //parser.loadFile((m_sharedRes->dataPath / "xml" / "scene3Dtool_default.xml").string().c_str());
#else
    std::vector<uint8_t> vp;
    //m_sharedRes->res->loadResource(nullptr, vp, "xml/scene3Dtool_default.xml");
    //parser.loadFromBuffer(&vp);
#endif

    connectUINodes();
}

/** connect the UINode generated by the parsed config file to functions */
void Scene3DTool::connectUINodes() {
    m_rightSide = dynamic_cast<Div *>(this->getNode("rightSide"));
    if (!m_rightSide) LOGE << "ERROR in config.xml, Missing Entry with ID \"rightSide\"";

    m_sceneContainer = dynamic_cast<Div *>(this->getNode("container"));
    if (!m_sceneContainer) {
        LOGE << "ERROR in config.xml, Missing Entry with ID \"container\"";
    } else {
        m_sceneContainer->setFixAspect(m_sceneAspect);
        m_sceneContainer->setBackgroundColor(1.f, 1.f, 1.f,
                                             1.f);  // white background for better reproduction of alpha values
    }

    m_sceneBackImg = dynamic_cast<Image *>(this->getNode("backImg"));
    if (!m_sceneBackImg) {
        LOGE << "ERROR in config.xml, Missing Entry with ID \"backImg\"";
    } else {
        m_sceneBackImg->setVisibility(false);
    }

    // callbacks are defined inside class constructor
    m_scene3D = dynamic_cast<Scene3D<CsPerspFbo> *>(this->getNode("scene3D"));
    if (!m_scene3D) {
        LOGE << "ERROR in config.xml, Missing Entry with ID \"scene3D\"";
    } else {
        getWindow()->setInputFocusNode(m_scene3D);
        m_scene3D->setMouseRotScale(m_mouseRotScale.x, m_mouseRotScale.y);
        m_scene3D->setMouseRotExp(m_mouseRotExp);

        // called when camera is selected
        m_scene3D->setAddGizmoCb([this](transMode m) {
            switch (m) {
                case transMode::translate: objectToolClicked(ToolBarIcon::translate); break;
                case transMode::rotate: objectToolClicked(ToolBarIcon::rotate); break;
                case transMode::none: objectToolClicked(ToolBarIcon::select); break;
                case transMode::twWidget: objectToolClicked(ToolBarIcon::twWidget); break;
                default: break;
            }
        });

        m_scene3D->setDeselectAllCb([this] {
            if (m_toolBar && m_toolBar->isVisible()) {
                objectToolClicked(ToolBarIcon::select);
            }
        });

        m_scene3D->addInitCb([this] {
            // bind the scene camera to the gizmo widget
            if (m_scene3D && m_scene3D->getSceneCam() && m_axesGizmo) {
                m_axesGizmo->setModelCam(m_scene3D->getSceneCamDef());
            }

            // add callbacks to the translation gizmo plane, in order to switch
            // the TransformWidget accordingly
            if (m_scene3D->getGizmos() && m_scene3D->getGizmos()->at(0)) {
                for (auto &it : *m_scene3D->getGizmos()->at(0)->getPlanes()) {
                    it->pushClickCb(this, [this, it] {
                        if (it->isSelected() && m_transWidget && m_transWidget->getPlaneType() != it->getPlaneType()) {
                            m_transWidget->setPlane(it->getPlaneType());
                        }
                    });
                }
            }
        });

        getWindow()->addGlobalKeyDownCb(this, [this](const hidData& data) {
            if (data.key == GLSG_KEY_LEFT_CONTROL ||
                data.key == GLSG_KEY_RIGHT_CONTROL && m_toolBarIcons[ToolBarIcon::coarseFine] &&
                    m_toolBarIcons[ToolBarIcon::coarseFine]->getToggleState() != 1) {
                m_toolBarIcons[ToolBarIcon::coarseFine]->setToggleState(1);
                setModifyCoarseFine();
                setDrawFlag();
            }

            if (data.key == GLSG_KEY_LEFT_SHIFT ||
                data.key == GLSG_KEY_RIGHT_SHIFT && m_toolBarIcons[ToolBarIcon::coarseFine] &&
                    m_toolBarIcons[ToolBarIcon::coarseFine]->getToggleState() != 2) {
                m_toolBarIcons[ToolBarIcon::coarseFine]->setToggleState(2);
                setModifyCoarseFine();
                setDrawFlag();
            }
        });

        getWindow()->addGlobalKeyUpCb(this, [this](const hidData& data) {
            if ((data.key == GLSG_KEY_LEFT_CONTROL || data.key == GLSG_KEY_RIGHT_CONTROL ||
                 data.key == GLSG_KEY_LEFT_SHIFT || data.key == GLSG_KEY_RIGHT_SHIFT) &&
                m_toolBarIcons[ToolBarIcon::coarseFine] &&
                m_toolBarIcons[ToolBarIcon::coarseFine]->getToggleState() != 0) {
                m_toolBarIcons[ToolBarIcon::coarseFine]->setToggleState(0);
                setModifyCoarseFine();
                setDrawFlag();
            }
        });
    }

    m_axesGizmo = dynamic_cast<Gizmo *>(this->getNode("gizmo"));
    if (!m_axesGizmo) {
        LOGE << "ERROR in config.xml, Missing Entry with ID \"gizmo\"";
    } else {
        m_axesGizmo->setScissorChildren(true);
    }

    m_transWidget = dynamic_cast<TransformWidget *>(this->getNode("transWidget"));
    if (!m_transWidget) {
        LOGE << "ERROR in config.xml, Missing Entry with ID \"transWidget\"";
    } else {
        m_transWidget->setScissorChildren(true);
        /*
                m_transWidget->setPlaneSwitchCb([this](transMode m, twPlane p) {

                    // check which gizmo is selected
                    auto g = m_scene3D->getGizmos();
                    for (auto &it : *g)
                        it->setVisibility(false);

                    if (!(g && g->at((int)m))) return;
                    // if the right gizmo is not active switch
                    if (!g->at((int)m)->isVisible() && m_scene3D &&
           m_scene3D->getObjectSelector())
                    {
                        m_transWidget->setBlockStateChange(true);
                        m_scene3D->getObjectSelector()->setTransMode(m);    //
           make the right gizmo visible
                        m_transWidget->setBlockStateChange(false);
                    }
                    if (m == transMode::translate && g->at((int)m)->getPlanes())
                    {
                        // deselect all axes
                        if (g->at((int)m)->getAxes())
                            for (auto &aIt : *g->at((int)m)->getAxes())
                                aIt->setSelected(false);

                        // get corresponding plane
                        auto plns = g->at((int)m)->getPlanes();

                        // select the plane corresponding to the actual
           transformation for (auto &pit : *plns) pit->setSelected(p ==
           pit->getPlaneType());

                    } else if (m == transMode::rotate &&
           g->at((int)m)->getAxes())
                    {
                        // get corresponding plane
                        auto axs = g->at((int)m)->getAxes();

                        // select the axes corresponding to the actual
           transformation if (p == twPlane::xy)
                        {
                            axs->at(0)->setSelected(false);
                            axs->at(1)->setSelected(true);
                            axs->at(2)->setSelected(true);
                        }
                        else if (p == twPlane::xz)
                        {
                            axs->at(0)->setSelected(true);
                            axs->at(1)->setSelected(true);
                            axs->at(2)->setSelected(false);
                        }
                        else if (p == twPlane::yz)
                        {
                            axs->at(0)->setSelected(true);
                            axs->at(1)->setSelected(false);
                            axs->at(2)->setSelected(true);
                        }
                    }
                    setDrawFlag();
                    getSharedRes()->requestRedraw = true;
                });
        */
    }

    m_toolBar = dynamic_cast<Gizmo *>(this->getNode("toolBar"));
    if (!m_toolBar) {
        LOGE << "ERROR in config.xml, Missing Entry with ID \"toolBar\"";
    }

    //------------------------------------------------------------------------------

    // check if the config file has all definitions we need
    // conversion to enum for performance reasons
    unordered_map<ToolBarIcon, const char *> str_to_enum;
    str_to_enum[ToolBarIcon::select]     = "tb_select";
    str_to_enum[ToolBarIcon::translate]  = "tb_translate";
    str_to_enum[ToolBarIcon::rotate]     = "tb_rotate";
    str_to_enum[ToolBarIcon::twWidget]   = "tb_twWidget";
    str_to_enum[ToolBarIcon::pan]        = "tb_pan";
    str_to_enum[ToolBarIcon::orbit]      = "tb_orbit";
    str_to_enum[ToolBarIcon::zoom]       = "tb_zoom";
    str_to_enum[ToolBarIcon::zoomReset]  = "tb_zoomReset";
    str_to_enum[ToolBarIcon::coarseFine] = "tb_coarseFine";

    // menu icons
    for (auto &[ico, snd] : str_to_enum) {
        m_toolBarIcons[ico] = dynamic_cast<ImageButton *>(this->getNode(snd));
        if (!m_toolBarIcons[ico]) {
            LOGE << "ERROR in config.xml, Missing Entry with ID \"" << snd << "\"";
        } else {
            m_toolBarIcons[ico]->setFocusAllowed(false);
            m_toolBarIcons[ico]->setLod(1.f);

            if (ico != ToolBarIcon::coarseFine) {
                m_toolBarIcons[ico]->setIsToggle(false);
            }

            if (ico == ToolBarIcon::translate || ico == ToolBarIcon::rotate) {
                m_toolBarIcons[ico]->setDisabled(true, true);
            }

            if (ico == ToolBarIcon::select || ico == ToolBarIcon::translate ||
                ico == ToolBarIcon::rotate || ico == ToolBarIcon::twWidget) {
                m_objToolIcons[ico] = dynamic_cast<ImageButton *>(this->getNode(snd));

                if (ico == ToolBarIcon::translate || ico == ToolBarIcon::rotate ||
                    ico == ToolBarIcon::twWidget) {
                    m_objTransIcons[ico] = dynamic_cast<ImageButton *>(this->getNode(snd));
                }
            } else if (ico == ToolBarIcon::pan || ico == ToolBarIcon::orbit || ico == ToolBarIcon::zoom) {
                m_viewToolIcons[ico] = dynamic_cast<ImageButton *>(this->getNode(snd));
            }
        }
    }

    for (auto &it : m_objToolIcons) {
        it.second->setIsToggle(true);
        it.second->setClickedCb([it, this] { objectToolClicked(it.first); });
        // it.second->addMouseClickCb([it, this](hidData& data) {
        // objectToolClicked(it.first); });
    }

    for (auto &it : m_viewToolIcons) {
        it.second->setIsToggle(true);
        it.second->setClickedCb([it, this] { viewToolClicked(it.first); });
        // it.second->addMouseClickCb([it, this](hidData& data) {
        // viewToolClicked(it.first); });
    }

    if (m_toolBarIcons[ToolBarIcon::pan]) {
        /*
                m_toolBarIcons[ToolBarIcon::pan]->setCanReceiveDrag(true);
                m_toolBarIcons[ToolBarIcon::pan]->addMouseDragCb([this](hidData*
           data){ vec2 mp = vec2(data.mousePos.x / getSize().x,
           data.mousePos.y / getSize().y); auto cam =
           m_scene3D->getSceneCamSet()->getInteractCam();

                    if (*data.dragStart)
                    {
                        startMouseDrag(cam, data);
                        cam->mouseDownRight(mp.x, mp.y);
                    }

                    glm::vec2 rs{1.f};
                    cam->mouseDrag(mp.x, mp.y, true, data.altPressed,
           data.ctrlPressed, rs); setDrawFlag();
                });
        */
        m_toolBarIcons[ToolBarIcon::pan]->addMouseUpCb([this](const hidData& data) {
            if (data.dragging) {
                resetMousePos();
            }
        });

        m_toolBarIcons[ToolBarIcon::pan]->addMouseUpRightCb([this](const hidData& data) {
            if (data.dragging) {
                resetMousePos();
            }
        });
    }

    if (m_toolBarIcons[ToolBarIcon::zoomReset]) {
        m_toolBarIcons[ToolBarIcon::zoomReset]->setClickedCb([this] { resetZoom(); });
        m_toolBarIcons[ToolBarIcon::zoomReset]->addMouseUpRightCb([this](const hidData& data) { resetZoom(); });
    }

    if (m_toolBarIcons[ToolBarIcon::coarseFine]) {
        m_toolBarIcons[ToolBarIcon::coarseFine]->setClickedCb([this] { setModifyCoarseFine(); });
        m_toolBarIcons[ToolBarIcon::coarseFine]->addMouseUpRightCb([this](const hidData& data) { setModifyCoarseFine(); });
    }

    objectToolClicked(ToolBarIcon::select);
}

void Scene3DTool::startMouseDrag(TrackBallCam *cam, const hidData& data) {
    cam->setInteractionStart();
    m_dragStartPos.x = data.mousePos.x;
    m_dragStartPos.y = data.mousePos.y;
    getWindow()->setMouseCursorVisible(false);
}

void Scene3DTool::resetMousePos() {
    getWindow()->setMouseCursorVisible(true);

#ifdef ARA_USE_GLFW
    runOnMainThread([this] {
        glfwSetCursorPos(getWindow()->getWinHandle()->getCtx(), m_dragStartPos.x, m_dragStartPos.y);
        return true;
    });
#elif _WIN32
    glm::vec2 winOffs;
    if (getWindow()->extGetWinOffs()) winOffs = getWindow()->extGetWinOffs()();

    // in contrast to GLFW this must be relative to the screen not the window
    SetCursorPos((int)winOffs.x + (int)m_dragStartPos.x * sceneData::inst()->contentScale.x,
                 (int)winOffs.y + (int)m_dragStartPos.y * sceneData::inst()->contentScale.x);
#endif
}

void Scene3DTool::resetZoom() {
    if (!m_scene3D) return;

    // the scene camera should look from behind the MRD camera towards the models center the scene cameras up-vector
    // should be identical to the basePlanes up-vector

    auto objSel   = m_scene3D->getObjectSelector();
    auto sceneCam = m_scene3D->getSceneCamDef();
    if (objSel && sceneCam && m_aimingNode && m_focusNode) {
        // get the vector point from the models center to the MRD camera

        // transform the model's bounding box into world space
        m_bb[0] = m_focusNode->getBoundingBoxMin();
        m_bb[1] = m_focusNode->getBoundingBoxMax();
        for (auto &i : m_bb) {
            i = *m_focusNode->getModelMat() * vec4(i, 1.f);
        }

        // get the models center in world space
        m_modelCenter = (m_bb[1] - m_bb[0]) * 0.5f + m_bb[0];

        // vector from model center to MRD camera
        m_modelCamVec = m_aimingNode->getTransVec() - m_modelCenter;

        // m_modelCamVec may be zero, catch this
        if (std::abs(glm::compAdd(m_modelCamVec)) < 1.e-7f) switch (m_scene3D->getBasePlane()) {
                case basePlane::xz: m_modelCamVec = vec3{0.f, 0.f, 1.f}; break;
                case basePlane::xy: m_modelCamVec = vec3{0.f, 1.f, 0.f}; break;
                case basePlane::yz: m_modelCamVec = vec3{0.f, 0.f, 1.f}; break;
            }
        else
            m_modelCamVec = glm::normalize(m_modelCamVec);

        // take base-plane as up vector
        switch (m_scene3D->getBasePlane()) {
            case basePlane::xz: m_upVec = vec3{0.f, 1.f, 0.f}; break;
            case basePlane::xy: m_upVec = vec3{0.f, 0.f, 1.f}; break;
            case basePlane::yz: m_upVec = vec3{1.f, 0.f, 0.f}; break;
        }

        // in case the modelCamVec is equal to the upVec, the lookAt matrix will
        // contain invalid values
        if (glm::compAdd(glm::abs(m_upVec - m_modelCamVec)) < 1.e-5f) {
            // calculate a rotation between the standard modelcamvec and the
            // actual one apply this rotation to the standard upvec
            m_rot   = RotationBetweenVectors(m_modelCamVec, m_stdCamVec);
            m_upVec = glm::normalize(vec3(m_rot * vec4(m_stdUpVec, 0.f)));

            // snap the upVec to the coordinate systems axes
            std::map<float, int> upVecSort;
            for (int i = 0; i < 3; i++) upVecSort[std::abs(m_upVec[i])] = i;

            memset(&m_upVec[0], 0, 12);
            m_upVec[(--upVecSort.end())->second] = 1.f;
        }

        m_rzViewMat = inverse(lookAt(m_modelCenter + m_modelCamVec, m_modelCenter, m_upVec));

        trackballPreset p;
        extractEulerAngleYXZ(m_rzViewMat, p.rotEuler.y, p.rotEuler.x, p.rotEuler.z);

        // create a cube in size of the bounding box
        vec4 cube[8] = {vec4(m_bb[0].x, m_bb[0].y, m_bb[0].z, 1.f), vec4(m_bb[1].x, m_bb[0].y, m_bb[0].z, 1.f),
                        vec4(m_bb[1].x, m_bb[1].y, m_bb[0].z, 1.f), vec4(m_bb[0].x, m_bb[1].y, m_bb[0].z, 1.f),
                        vec4(m_bb[0].x, m_bb[0].y, m_bb[1].z, 1.f), vec4(m_bb[1].x, m_bb[0].y, m_bb[1].z, 1.f),
                        vec4(m_bb[1].x, m_bb[1].y, m_bb[1].z, 1.f), vec4(m_bb[0].x, m_bb[1].y, m_bb[1].z, 1.f)};

        // apply the view rotation to the cube and calculate a bounding box
        // around it
        for (auto &i : cube) i = m_rzViewMat * (i - vec4(m_modelCenter, 0.f));

        for (int i = 0; i < 3; i++) {
            m_newBb[0][i] = numeric_limits<float>::max();
            m_newBb[1][i] = numeric_limits<float>::min();
        }

        for (auto &i : cube) {
            for (int j = 0; j < 3; j++) {
                if (i[j] > m_newBb[1][j]) {
                    m_newBb[1][j] = i[j];
                }
                if (i[j] < m_newBb[0][j]) {
                    m_newBb[0][j] = i[j];
                }
            }
        }

        // get the distance from the model to the new scene camera position, in
        // order to have to whole model filling the screen. this must be done
        // respecting both horizontal and vertical FOV
        float dh = std::fabs(m_newBb[1].x - m_newBb[0].x) * 0.5f / std::tan(sceneCam->getFov() * sceneCam->getAspect() * 0.5f);
        float dv = std::fabs(m_newBb[1].y - m_newBb[0].y) * 0.5f / std::tan(sceneCam->getFov() * 0.5f);

        p.pos = m_modelCenter + (m_modelCamVec * ((dh > dv ? dh : dv) + std::fabs(m_newBb[1].z - m_newBb[0].z) * 0.5f));

        // check if camera will be clipped, distance between scene and mrd
        // camera must be at least 1.f (clipping plane)
        float distSceneCam = glm::distance(m_modelCenter, p.pos);
        float distMRDCam   = glm::distance(m_modelCenter, m_aimingNode->getTransVec());

        p.pos += (distMRDCam - distSceneCam) > -1.f ? m_modelCamVec * (distMRDCam - distSceneCam + 2.f) : vec3{0.f};

        sceneCam->fadeTo(p.rotEuler, p.pos, 0.5);

        // add a callback which will be executed on every draw until the
        // sceneCam fade stopped
        m_scene3D->addGlCb("animCam", [this, sceneCam]() {
            if (sceneCam) {
                sceneCam->updateFade();
            }

            m_scene3D->m_reqRenderPasses[renderPass::objectMap] = true;
            m_scene3D->m_reqRenderPasses[renderPass::shadowMap] = true;
            m_scene3D->m_reqRenderPasses[renderPass::scene]      = true;
            getSharedRes()->requestRedraw                      = true;
            return sceneCam->fadeStopped();
        });
    }
}

void Scene3DTool::objectToolClicked(ToolBarIcon idx) {
    if (!m_scene3D || m_preventObjToolClick) return;

    if (m_transWidget) {
        m_transWidget->setVisibility(false);
    }

    m_preventObjToolClick = true;

    switch (idx) {
        case ToolBarIcon::select:
            enableNetCamHighlight(false);
            if (m_scene3D->getObjectSelector() && !m_scene3D->getNetCameras()->empty()) {
                m_scene3D->getObjectSelector()->deselect();
            }

            getWindow()->setInputFocusNode(m_scene3D);
            setToolState(toolState::objToolBlocked);

            if (m_transWidget) m_transWidget->setVisibility(false);
            break;
        case ToolBarIcon::translate:  // change to translation
            enableNetCamHighlight(false);

            if (m_scene3D->getObjectSelector() && !m_scene3D->getNetCameras()->empty()) {
                if (!m_scene3D->getNetCameras()->front()->isSelected())
                    m_scene3D->getObjectSelector()->selectObj(m_scene3D->getNetCameras()->front()->getObjId(), true);
                m_scene3D->getObjectSelector()->setTransMode(transMode::translate);
            }

            getWindow()->setInputFocusNode(m_scene3D);
            setToolState(toolState::allUnBlocked);

            if (m_transWidget) m_transWidget->setTransMode(transMode::translate, true);

            break;
        case ToolBarIcon::rotate:  // change to rotatio
            enableNetCamHighlight(false);

            if (m_scene3D->getObjectSelector() && !m_scene3D->getNetCameras()->empty()) {
                if (!m_scene3D->getNetCameras()->front()->isSelected())
                    m_scene3D->getObjectSelector()->selectObj(m_scene3D->getNetCameras()->front()->getObjId(), true);
                m_scene3D->getObjectSelector()->setTransMode(transMode::rotate);
            }

            getWindow()->setInputFocusNode(m_scene3D);
            setToolState(toolState::allUnBlocked);

            if (m_transWidget) m_transWidget->setTransMode(transMode::rotate, true);

            break;
        case ToolBarIcon::twWidget:  // change to TransformWidget

            m_scene3D->deselectAll();

            if (m_scene3D->getObjectSelector()) m_scene3D->getObjectSelector()->setTransMode(transMode::twWidget);

            enableNetCamHighlight(true);
            setToolState(toolState::allUnBlocked);

            if (m_transWidget) {
                m_transWidget->setVisibility(true);
                // immediately set the keyboard focus to the TW Widget
                getWindow()->setInputFocusNode(m_transWidget);
            }
            break;
        default: break;
    }

    m_preventObjToolClick = false;

    for (auto &it : m_objToolIcons)
        if (it.first != ToolBarIcon::none) it.second->setSelected(false, true);

    if (idx != ToolBarIcon::none) m_objToolIcons[idx]->setSelected(true, true);
}

void Scene3DTool::setToolState(toolState st) {
    m_toolState = st;

    switch (st) {
        case toolState::objToolBlocked:

            for (auto &it : m_objTransIcons) {
                if (it.second) {
                    if (it.second->getState() == state::selected) it.second->setSelected(false, true);

                    if (it.second->getState() != state::disabled) it.second->setDisabled(true, true);
                }
            }

            break;
        case toolState::allUnBlocked:
            for (auto &it : m_toolBarIcons)
                if (it.second && it.second->getState() == state::disabled) it.second->setDisabled(false, true);

            break;
    }
}

void Scene3DTool::viewToolClicked(ToolBarIcon idx) {
    if (!m_scene3D) return;

    bool selected = m_viewToolIcons[idx]->isSelected();

    for (auto &it : m_viewToolIcons) it.second->setSelected(false, true);

    m_viewToolIcons[idx]->setSelected(selected, true);

    m_scene3D->getSceneCamDef()->setRotateInteraction(rm::rightDrag);
    m_scene3D->getSceneCamDef()->setTransInteraction(trm::shiftRightDrag);
    m_scene3D->getSceneCamDef()->setZoomInteraction(zm::ctrlRightDrag);

    switch (idx) {
        case ToolBarIcon::pan:
            m_scene3D->getSceneCamDef()->setTransInteraction(selected ? trm::leftOrShiftRightDrag
                                                                      : trm::shiftRightDrag);
            break;
        case ToolBarIcon::orbit:
            m_scene3D->getSceneCamDef()->setRotateInteraction(selected ? rm::leftOrRightDrag : rm::rightDrag);
            break;
        case ToolBarIcon::zoom:
            m_scene3D->getSceneCamDef()->setZoomInteraction(selected ? zm::leftOrCtrlRightDrag : zm::ctrlRightDrag);
            break;
        default: break;
    }
}

void Scene3DTool::setMouseRotScale(float x, float y) {
    m_mouseRotScale.x = x;
    m_mouseRotScale.y = y;

    if (m_scene3D) m_scene3D->setMouseRotScale(x, y);
}

void Scene3DTool::setMouseRotExp(float exp) {
    m_mouseRotExp = exp;

    if (m_scene3D) m_scene3D->setMouseRotExp(exp);
}

void Scene3DTool::setModifyCoarseFine() {
    if (m_toolBarIcons[ToolBarIcon::coarseFine] && m_scene3D) {
        auto    s  = m_toolBarIcons[ToolBarIcon::coarseFine]->getToggleState();  // 0 = normal, 1 = fine, 2 = coarse
        cfState ns = s == 0 ? cfState::normal : (s == 1 ? cfState::fine : cfState::coarse);

        if (ns != m_scene3D->getCfState()) m_scene3D->setCfState(ns);

        if (m_transWidget) m_transWidget->setCoarseFine(ns);
    }
}

void Scene3DTool::setTransWidget(SceneNode *node) {
    if (m_transWidget) {
        m_transWidget->setModelNode(node);
        m_transWidget->setVisibility(false);
        m_transWidget->setEnableCb([this] {
            // hide gizmo
            if (m_scene3D) {
                for (auto &it : *m_scene3D->getGizmos()) it->setVisibility(false);

                enableNetCamHighlight(true);
            }
        });
    }
}

void Scene3DTool::enableNetCamHighlight(bool val) {
    if (m_scene3D && m_scene3D->getNetCameras() && !m_scene3D->getNetCameras()->empty()) {
        auto cam = m_scene3D->getNetCameras()->front();
        cam->getChildren()->front()->setSelected(val);

        // switch netcamera selected
        cam->iterateNode(cam->getChildren()->front(), [val](SceneNode *node) {
            node->m_selectable = val;
            return true;
        });

        m_scene3D->setDrawProcSteps();
        getSharedRes()->requestRedraw = true;
    }
}

void Scene3DTool::setKeyTransStep(float fine, float normal, float coarse) const {
    if (m_scene3D) {
        m_scene3D->setKeyTransStep(fine, normal, coarse);
    }

    if (m_transWidget) {
        m_transWidget->setKeyTransStep(fine, normal, coarse);
    }
}

void Scene3DTool::setKeyRotStep(float fine, float normal, float coarse) const {
    if (m_scene3D) {
        m_scene3D->setKeyRotStep(glm::radians(fine), glm::radians(normal), glm::radians(coarse));
    }

    if (m_transWidget) {
        m_transWidget->setKeyRotStep(fine, normal, coarse);
    }
}

}  // namespace ara
